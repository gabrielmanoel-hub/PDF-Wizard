<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PDF wizard – Gratuito no Navegador</title>
  <meta name="description" content="Ferramentas de PDF 100% no navegador: unir, dividir, extrair, girar, reordenar, anotar e compactar levemente. Sem enviar arquivos para servidores." />
  <link rel="icon" href="data:," />
  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- pdf-lib UMD (global: PDFLib) -->
  <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
  <!-- pdf.js (renderização de páginas) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script>
    if (window['pdfjsLib']) {
      pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    }
  </script>
  <!-- jsPDF -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <!-- SortableJS -->
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
  <style>
    :root {
      --primary: #6366f1;
      --primary-light: #818cf8;
      --primary-dark: #4f46e5;
      --secondary: #f472b6;
      --success: #10b981;
      --warning: #f59e0b;
      --error: #ef4444;
    }
    
    body {
      font-family: 'Inter', sans-serif;
      background: linear-gradient(135deg, #f5f7fa 0%, #e4e7eb 100%);
      min-height: 100vh;
    }
    
    .header-gradient {
      background: linear-gradient(90deg, var(--primary) 0%, var(--primary-light) 100%);
    }
    
    .tool-card {
      transition: all 0.3s ease;
      border: 1px solid transparent;
      background: white;
      border-radius: 16px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
    }
    
    .tool-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
      border-color: var(--primary-light);
    }
    
    .tab {
      display: none;
      animation: fadeIn 0.3s ease;
    }
    
    .tab.active {
      display: block;
    }
    
    .thumb {
      border: 1px solid #e5e7eb;
      border-radius: 12px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.03);
      background: white;
      overflow: hidden;
      transition: all 0.2s ease;
    }
    
    .thumb:hover {
      transform: scale(1.02);
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
    }
    
    .thumb canvas {
      width: 100%;
      height: auto;
      display: block;
    }
    
    .thumb.selected {
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.3);
    }
    
    .spinner {
      border: 2px solid rgba(0, 0, 0, 0.08);
      border-top-color: var(--primary);
      border-radius: 9999px;
      width: 18px;
      height: 18px;
      animation: spin 1s linear infinite;
      display: inline-block;
    }
    
    .btn-primary {
      background: linear-gradient(90deg, var(--primary) 0%, var(--primary-light) 100%);
      color: white;
      border: none;
      border-radius: 12px;
      padding: 10px 20px;
      font-weight: 500;
      transition: all 0.2s ease;
      box-shadow: 0 2px 4px rgba(99, 102, 241, 0.3);
    }
    
    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(99, 102, 241, 0.4);
    }
    
    .btn-primary:active {
      transform: translateY(0);
    }
    
    .btn-secondary {
      background: #f8fafc;
      color: #64748b;
      border: 1px solid #e2e8f0;
      border-radius: 12px;
      padding: 10px 20px;
      font-weight: 500;
      transition: all 0.2s ease;
    }
    
    .btn-secondary:hover {
      background: #f1f5f9;
      transform: translateY(-2px);
    }
    
    input[type="file"] {
      border: 2px dashed #cbd5e1;
      border-radius: 12px;
      padding: 16px;
      width: 100%;
      background: #f8fafc;
      transition: all 0.2s ease;
    }
    
    input[type="file"]:hover {
      border-color: var(--primary-light);
      background: #f0f9ff;
    }
    
    input[type="text"], input[type="number"] {
      border: 1px solid #e2e8f0;
      border-radius: 12px;
      padding: 12px 16px;
      width: 100%;
      transition: all 0.2s ease;
    }
    
    input[type="text"]:focus, input[type="number"]:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2);
    }
    
    .badge {
      display: inline-flex;
      align-items: center;
      padding: 4px 12px;
      border-radius: 9999px;
      font-size: 0.75rem;
      font-weight: 500;
      background: #f1f5f9;
      color: #475569;
    }
    
    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }
    
    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    .progress-bar {
      height: 6px;
      border-radius: 3px;
      background: #e2e8f0;
      overflow: hidden;
      margin-top: 8px;
    }
    
    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--primary) 0%, var(--primary-light) 100%);
      border-radius: 3px;
      transition: width 0.3s ease;
    }
    
    .toast {
      position: fixed;
      bottom: 20px;
      right: 20px;
      padding: 12px 20px;
      border-radius: 12px;
      background: white;
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
      display: flex;
      align-items: center;
      gap: 10px;
      transform: translateY(100px);
      opacity: 0;
      transition: all 0.3s ease;
      z-index: 1000;
    }
    
    .toast.visible {
      transform: translateY(0);
      opacity: 1;
    }
    
    .toast.success {
      border-left: 4px solid var(--success);
    }
    
    .toast.error {
      border-left: 4px solid var(--error);
    }
    
    .toast.info {
      border-left: 4px solid var(--primary);
    }
  </style>
</head>
<body class="text-gray-800">
  <header class="border-b header-gradient text-white">
    <div class="max-w-6xl mx-auto p-4 flex flex-col md:flex-row gap-3 md:items-center md:justify-between">
      <div class="flex items-center gap-3">
        <div class="w-10 h-10 rounded-2xl bg-white text-indigo-600 flex items-center justify-center font-bold shadow-md">PDF</div>
        <div>
          <h1 class="text-xl font-bold">PDF wizard</h1>
          <p class="text-sm text-indigo-100">Tudo no seu navegador · sem upload · gratuito</p>
        </div>
      </div>
    </div>
  </header>

  <main class="max-w-6xl mx-auto p-6 space-y-8">
    <section class="bg-yellow-50 border border-yellow-200 p-4 rounded-2xl text-sm flex items-start gap-3">
      <div class="text-yellow-700 bg-yellow-100 p-2 rounded-full">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
        </svg>
      </div>
      <div>
        <h3 class="font-medium">Processamento local</h3>
        <p class="mt-1">Todos os arquivos são processados <strong>localmente</strong> no seu navegador. Nada é enviado para servidores.</p>
      </div>
    </section>

    <!-- MENU DE FERRAMENTAS (cards) -->
    <section class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6">
      <div class="tool-card p-6 rounded-2xl cursor-pointer" data-tab="tab-merge">
        <div class="w-12 h-12 rounded-xl bg-indigo-100 text-indigo-600 flex items-center justify-center mb-4">
          <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6" />
          </svg>
        </div>
        <h2 class="text-lg font-semibold mb-2">Unir PDFs</h2>
        <p class="text-sm text-gray-500">Combine múltiplos arquivos em um só.</p>
      </div>
      
      <div class="tool-card p-6 rounded-2xl cursor-pointer ring-2 ring-indigo-200" data-tab="tab-split">
        <div class="w-12 h-12 rounded-xl bg-pink-100 text-pink-600 flex items-center justify-center mb-4">
          <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 5l7 7m0 0l-7 7m7-7H3" />
          </svg>
        </div>
        <h2 class="text-lg font-semibold mb-2">Dividir / Extrair</h2>
        <p class="text-sm text-gray-500">Extraia páginas específicas ou intervalos.</p>
      </div>
      
      <div class="tool-card p-6 rounded-2xl cursor-pointer" data-tab="tab-rotate">
        <div class="w-12 h-12 rounded-xl bg-amber-100 text-amber-600 flex items-center justify-center mb-4">
          <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
          </svg>
        </div>
        <h2 class="text-lg font-semibold mb-2">Girar / Reordenar</h2>
        <p class="text-sm text-gray-500">Rotacione e arraste páginas para mudar ordem.</p>
      </div>
      
      <div class="tool-card p-6 rounded-2xl cursor-pointer" data-tab="tab-annotate">
        <div class="w-12 h-12 rounded-xl bg-cyan-100 text-cyan-600 flex items-center justify-center mb-4">
          <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z" />
          </svg>
        </div>
        <h2 class="text-lg font-semibold mb-2">Anotar</h2>
        <p class="text-sm text-gray-500">Adicione textos, assinaturas e imagens.</p>
      </div>
      
      <div class="tool-card p-6 rounded-2xl cursor-pointer" data-tab="tab-compress">
        <div class="w-12 h-12 rounded-xl bg-emerald-100 text-emerald-600 flex items-center justify-center mb-4">
          <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
          </svg>
        </div>
        <h2 class="text-lg font-semibold mb-2">Compactar</h2>
        <p class="text-sm text-gray-500">Reduza o tamanho do PDF (leve).</p>
      </div>
    </section>

    <!-- TABS / FERRAMENTAS -->
    <!-- SPLIT / EXTRACT -->
    <section id="tab-split" class="tab bg-white p-6 rounded-2xl shadow-md">
      <div class="flex items-center justify-between mb-4">
        <h2 class="text-xl font-semibold text-gray-800">Dividir / Extrair páginas</h2>
        <span class="badge">pré-visualização</span>
      </div>
      <p class="text-gray-600 mb-6">Abra um PDF, selecione páginas clicando nas miniaturas ou use o campo de intervalo (ex.: 1-3,5,10) e exporte.</p>
      
      <div class="flex flex-col lg:flex-row gap-6">
        <div class="space-y-4 w-full lg:w-1/3">
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-2">Selecionar arquivo PDF</label>
            <input type="file" id="splitFile" accept="application/pdf" class="cursor-pointer" />
          </div>
          
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-2">Intervalo de páginas</label>
            <input type="text" id="rangeInput" placeholder="Ex: 1-3,5,10" class="w-full" />
            <p class="text-xs text-gray-500 mt-1">Use vírgulas para separar páginas e hífen para intervalos</p>
          </div>
          
          <div class="grid grid-cols-2 gap-3">
            <button id="btnSelectAll" class="btn-secondary">Selecionar tudo</button>
            <button id="btnClearSel" class="btn-secondary">Limpar</button>
          </div>
          
          <div class="pt-4">
            <button id="btnExtractSelected" class="btn-primary w-full flex items-center justify-center gap-2">
              <span>Extrair páginas selecionadas</span>
              <svg id="extract-icon" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
              </svg>
              <span id="extract-spinner" class="spinner hidden"></span>
            </button>
            
            <div class="progress-bar mt-3 hidden" id="extract-progress">
              <div class="progress-fill" id="extract-progress-fill" style="width: 0%"></div>
            </div>
            
            <div id="splitStatus" class="text-sm text-gray-500 mt-2"></div>
          </div>
        </div>
        
        <div class="w-full lg:w-2/3">
          <div class="flex items-center justify-between mb-4">
            <h3 class="font-medium text-gray-700">Visualização das páginas</h3>
            <span id="pageCount" class="text-sm text-gray-500">0 páginas carregadas</span>
          </div>
          
          <div id="splitGrid" class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4"></div>
        </div>
      </div>
    </section>

    <!-- Outras abas (mantidas como estão, apenas melhoradas visualmente) -->
     <!-- MERGE -->
    <section id="tab-merge" class="tab bg-white p-6 rounded-2xl shadow-md">
      <!-- Conteúdo mantido igual, mas com classes atualizadas -->
    </section>

    <!-- ROTATE / REORDER -->
    <section id="tab-rotate" class="tab bg-white p-6 rounded-2xl shadow-md">
      <!-- Conteúdo mantido igual, mas com classes atualizadas -->
    </section>

    <!-- ANNOTATE -->
    <section id="tab-annotate" class="tab bg-white p-6 rounded-2xl shadow-md">
      <!-- Conteúdo mantido igual, mas com classes atualizadas -->
    </section>

    <!-- COMPRESS -->
    <section id="tab-compress" class="tab bg-white p-6 rounded-2xl shadow-md">
      <!-- Conteúdo mantido igual, mas com classes atualizadas -->
    </section>

    <footer class="text-center text-sm text-gray-500 py-8">
      © <span id="year"></span> PDF Wizard – Feito para estudo.
      <br>
        <a href="Política-de-Privacidade.html" class="text-indigo-600 underline hover:text-indigo-800">Política de Privacidade</a>
        <a href="blog.html" class="text-indigo-600 underline hover:text-indigo-800 ml-2">Blog</a>
    </footer>
  </main>

  <div id="toast" class="toast">
    <svg id="toast-icon" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
    </svg>
    <span id="toast-message">Operação concluída com sucesso!</span>
  </div>

  <!-- Scripts -->
    <script src="./js/block.js" defer></script>
  <script>
    // libs
    const { PDFDocument, StandardFonts, rgb, degrees } = PDFLib;
    const $ = sel => document.querySelector(sel);
    const $$ = sel => Array.from(document.querySelectorAll(sel));
    const readAsArrayBuffer = file => new Promise((res, rej) => {
      const r = new FileReader(); r.onload = () => res(r.result); r.onerror = rej; r.readAsArrayBuffer(file);
    });
    const downloadBlob = (blob, filename) => { const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = filename; a.click(); setTimeout(()=>URL.revokeObjectURL(url), 1500); };

    // UI helpers
    const statusMap = {
      merge: '#mergeStatus', split: '#splitStatus', rr: '#rrStatus', ann: '#annStatus', cmp: '#cmpStatus'
    };
    
    function setStatus(key, html) { 
      const el = $(statusMap[key]); 
      if (el) el.innerHTML = html; 
    }
    
    function withSpinner(key, message) { 
      setStatus(key, `<span class='spinner'></span> ${message}`); 
    }
    
    function showToast(message, type = 'success') {
      const toast = $('#toast');
      const toastIcon = $('#toast-icon');
      const toastMessage = $('#toast-message');
      
      toastMessage.textContent = message;
      toast.className = 'toast';
      
      // Configurar ícone e cor baseado no tipo
      if (type === 'success') {
        toast.classList.add('success');
        toastIcon.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />';
        toastIcon.stroke = '#10b981';
      } else if (type === 'error') {
        toast.classList.add('error');
        toastIcon.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" />';
        toastIcon.stroke = '#ef4444';
      } else {
        toast.classList.add('info');
        toastIcon.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />';
        toastIcon.stroke = '#6366f1';
      }
      
      toast.classList.add('visible');
      
      // Auto-ocultar após 3 segundos
      setTimeout(() => {
        toast.classList.remove('visible');
      }, 3000);
    }

    document.getElementById('year').textContent = new Date().getFullYear();

    // Tabs open by clicking cards
    $$('.tool-card').forEach(card => card.addEventListener('click', () => {
      const id = card.dataset.tab;
      $$('.tab').forEach(t => t.classList.remove('active'));
      $(`#${id}`).classList.add('active');
      // highlight card
      $$('.tool-card').forEach(c => c.classList.remove('ring-2','ring-indigo-200'));
      card.classList.add('ring-2','ring-indigo-200');
      window.scrollTo({ top: 0, behavior: 'smooth' });
    }));

    // parseRange melhorado para lidar com intervalos como "1-3,5,10"
    function parseRange(text, max) {
      const set = new Set();
      if (!text) return set;
      
      text.split(',').map(s => s.trim()).forEach(part => {
        if (!part) return;
        
        // Verificar se é um intervalo (contém hífen)
        if (part.includes('-')) {
          const [startStr, endStr] = part.split('-').map(s => s.trim());
          const start = parseInt(startStr, 10);
          const end = parseInt(endStr, 10);
          
          if (isNaN(start) || isNaN(end)) return;
          
          const realStart = Math.max(1, Math.min(start, end));
          const realEnd = Math.min(max, Math.max(start, end));
          
          for (let i = realStart; i <= realEnd; i++) {
            set.add(i - 1); // Converter para índice 0-based
          }
        } else {
          // É um número único
          const page = parseInt(part, 10);
          if (!isNaN(page) && page >= 1 && page <= max) {
            set.add(page - 1); // Converter para índice 0-based
          }
        }
      });
      
      return set;
    }

    // ===================== SPLIT / EXTRACT =====================
    let splitState = { pdf: null, doc: null, numPages: 0 };

    $('#splitFile').addEventListener('change', async (e) => {
      const f = e.target.files[0]; if (!f) return;
      try {
        withSpinner('split','Carregando PDF...');
        $('#splitGrid').innerHTML = '';
        $('#pageCount').textContent = '0 páginas carregadas';
        
        const bytes = await readAsArrayBuffer(f);
        splitState.doc = await PDFDocument.load(bytes);
        splitState.numPages = splitState.doc.getPageCount();
        splitState.pdf = await pdfjsLib.getDocument({data: bytes}).promise;
        
        $('#pageCount').textContent = `${splitState.numPages} página${splitState.numPages !== 1 ? 's' : ''} carregada${splitState.numPages !== 1 ? 's' : ''}`;
        await renderSplitGrid();
        setStatus('split', `PDF carregado — ${splitState.numPages} página(s).`);
        showToast(`PDF carregado com ${splitState.numPages} páginas`, 'success');
      } catch (err) {
        console.error(err); 
        setStatus('split','Erro ao abrir PDF.');
        showToast('Erro ao carregar o PDF', 'error');
      }
    });

    async function renderSplitGrid() {
      const grid = $('#splitGrid'); 
      grid.innerHTML = '';
      
      for (let i = 1; i <= splitState.numPages; i++) {
        const page = await splitState.pdf.getPage(i);
        const vp = page.getViewport({scale: 0.25});
        const canvas = document.createElement('canvas'); 
        canvas.width = Math.floor(vp.width); 
        canvas.height = Math.floor(vp.height);
        const ctx = canvas.getContext('2d'); 
        
        // Renderizar a página
        await page.render({canvasContext: ctx, viewport: vp}).promise;

        const wrap = document.createElement('div'); 
        wrap.className = 'thumb p-3 relative';
        wrap.innerHTML = `
          <label class="flex items-center gap-2 p-2 cursor-pointer">
            <input type="checkbox" class="pageCheck absolute opacity-0" data-idx="${i-1}" />
            <span class="checkmark w-5 h-5 border border-gray-300 rounded-md flex-shrink-0"></span>
            <span class="text-sm font-medium">Página ${i}</span>
          </label>
        `;
        
        // Adicionar canvas
        wrap.appendChild(canvas);
        
        // Adicionar evento de clique para seleção
        const label = wrap.querySelector('label');
        const checkbox = wrap.querySelector('input');
        
        label.addEventListener('click', (e) => {
          if (e.target !== checkbox) {
            checkbox.checked = !checkbox.checked;
            updateThumbSelection(wrap, checkbox.checked);
            updateRangeFromCheckboxes();
          }
        });
        
        grid.appendChild(wrap);
      }
    }
    
    function updateThumbSelection(thumbElement, isSelected) {
      if (isSelected) {
        thumbElement.classList.add('selected');
        thumbElement.querySelector('.checkmark').style.backgroundColor = '#6366f1';
        thumbElement.querySelector('.checkmark').innerHTML = `
          <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-white" viewBox="0 0 20 20" fill="currentColor">
            <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd" />
          </svg>
        `;
      } else {
        thumbElement.classList.remove('selected');
        thumbElement.querySelector('.checkmark').style.backgroundColor = '';
        thumbElement.querySelector('.checkmark').innerHTML = '';
      }
    }

    $('#btnSelectAll').addEventListener('click', () => {
      $$('#splitGrid .pageCheck').forEach(ch => {
        ch.checked = true;
        updateThumbSelection(ch.closest('.thumb'), true);
      });
      updateRangeFromCheckboxes();
      setStatus('split','Todas selecionadas.');
    });
    
    $('#btnClearSel').addEventListener('click', () => {
      $$('#splitGrid .pageCheck').forEach(ch => {
        ch.checked = false;
        updateThumbSelection(ch.closest('.thumb'), false);
      });
      $('#rangeInput').value = '';
      setStatus('split','Seleção limpa.');
    });

    // Atualizar checkboxes a partir do campo de intervalo
    $('#rangeInput').addEventListener('input', () => {
      if (!splitState.numPages) return;
      
      const rangeText = $('#rangeInput').value;
      const selectedPages = parseRange(rangeText, splitState.numPages);
      
      $$('#splitGrid .pageCheck').forEach((ch, idx) => {
        ch.checked = selectedPages.has(idx);
        updateThumbSelection(ch.closest('.thumb'), selectedPages.has(idx));
      });
    });
    
    // Atualizar campo de intervalo a partir dos checkboxes
    function updateRangeFromCheckboxes() {
      const selectedIndices = $$('#splitGrid .pageCheck:checked').map(ch => parseInt(ch.dataset.idx, 10) + 1);
      
      if (selectedIndices.length === 0) {
        $('#rangeInput').value = '';
        return;
      }
      
      // Ordenar os índices
      selectedIndices.sort((a, b) => a - b);
      
      // Criar intervalos contíguos
      const ranges = [];
      let start = selectedIndices[0];
      let end = selectedIndices[0];
      
      for (let i = 1; i < selectedIndices.length; i++) {
        if (selectedIndices[i] === end + 1) {
          end = selectedIndices[i];
        } else {
          ranges.push(start === end ? start : `${start}-${end}`);
          start = selectedIndices[i];
          end = selectedIndices[i];
        }
      }
      
      ranges.push(start === end ? start : `${start}-${end}`);
      $('#rangeInput').value = ranges.join(',');
    }

    $('#btnExtractSelected').addEventListener('click', async () => {
      if (!splitState.doc) { 
        setStatus('split','Carregue um PDF primeiro.'); 
        showToast('Por favor, carregue um PDF primeiro', 'error');
        return; 
      }
      
      try {
        // Mostrar spinner e esconder ícone de download
        $('#extract-spinner').classList.remove('hidden');
        $('#extract-icon').classList.add('hidden');
        $('#extract-progress').classList.remove('hidden');
        $('#btnExtractSelected').disabled = true;
        
        withSpinner('split','Processando extração...');
        
        // Obter páginas selecionadas
        const checks = $$('#splitGrid .pageCheck:checked');
        const fromChecks = new Set(checks.map(ch => parseInt(ch.dataset.idx, 10)));
        
        // Também verificar o campo de intervalo para garantir sincronização
        const fromRange = parseRange($('#rangeInput').value, splitState.numPages);
        
        // Combinar as seleções
        const wanted = new Set([...fromChecks, ...fromRange]);
        
        if (wanted.size === 0) { 
          setStatus('split','Nenhuma página selecionada.'); 
          showToast('Selecione pelo menos uma página', 'error');
          
          $('#extract-spinner').classList.add('hidden');
          $('#extract-icon').classList.remove('hidden');
          $('#btnExtractSelected').disabled = false;
          return; 
        }
        
        const wantedArray = Array.from(wanted).sort((a, b) => a - b);
        
        // Atualizar barra de progresso
        $('#extract-progress-fill').style.width = '30%';
        
        const out = await PDFDocument.create();
        $('#extract-progress-fill').style.width = '60%';
        
        const pages = await out.copyPages(splitState.doc, wantedArray);
        $('#extract-progress-fill').style.width = '80%';
        
        pages.forEach(p => out.addPage(p));
        $('#extract-progress-fill').style.width = '90%';
        
        const bytes = await out.save(); 
        $('#extract-progress-fill').style.width = '100%';
        
        downloadBlob(new Blob([bytes], {type: 'application/pdf'}), 'extraido.pdf');
        setStatus('split', 'Pronto — download iniciado.');
        showToast('Extração concluída! O download começará em instantes.', 'success');
        
      } catch(err) { 
        console.error(err); 
        setStatus('split','Erro ao extrair páginas.');
        showToast('Erro durante a extração', 'error');
      } finally { 
        // Restaurar ícone e habilitar botão
        setTimeout(() => {
          $('#extract-spinner').classList.add('hidden');
          $('#extract-icon').classList.remove('hidden');
          $('#extract-progress').classList.add('hidden');
          $('#extract-progress-fill').style.width = '0%';
          $('#btnExtractSelected').disabled = false;
        }, 1000);
      }
      });

    // ===================== OUTRAS FERRAMENTAS =====================
    // (O código para outras ferramentas permanece similar, mas com melhorias visuais)
    // ... [código para merge, rotate, annotate, compress] ...
    
    // Unir PDFs (Merge)
    //--------------------------------------------------------------
    // ...adicione antes do comentário das outras ferramentas...

    // ...adicione no início do <script> (após as libs)...
const MAX_SIZE = 20 * 1024 * 1024; // 20MB

// ...substitua o bloco MERGE pelo abaixo...

$('#tab-merge').innerHTML = `
  <h2 class="text-xl font-semibold mb-4">Unir PDFs</h2>
  <input type="file" id="mergeFiles" multiple accept="application/pdf" class="mb-4" />
  <div id="mergePreviewGrid" class="grid grid-cols-2 md:grid-cols-3 gap-4 mb-4"></div>
  <button id="btnMerge" class="btn-primary">Unir e baixar</button>
  <div class="w-full bg-gray-200 rounded-full h-3 mb-2">
    <div id="mergeProgressBar" class="bg-indigo-500 h-3 rounded-full transition-all duration-300" style="width:0%"></div>
  </div>
  <div id="mergeStatus" class="text-sm text-gray-500 mt-2"></div>
`;

let mergeState = { files: [], pdfs: [], previews: [] };

$('#mergeFiles').addEventListener('change', async (e) => {
  const files = Array.from(e.target.files);
  mergeState.files = [];
  mergeState.pdfs = [];
  mergeState.previews = [];
  $('#mergePreviewGrid').innerHTML = '';
  for (const file of files) {
    if (file.size > MAX_SIZE) {
      setStatus('merge', 'Arquivo muito grande (máx. 20MB): ' + file.name);
      showToast('Arquivo muito grande: ' + file.name, 'error');
      continue;
    }
    mergeState.files.push(file);
    // Carregar para pdf-lib
    const bytes = await readAsArrayBuffer(file);
    const pdfDoc = await PDFDocument.load(bytes);
    mergeState.pdfs.push(pdfDoc);
    // Carregar para preview
    const previewPdf = await pdfjsLib.getDocument({data: bytes}).promise;
    mergeState.previews.push(previewPdf);
  }
  await renderMergePreviewGrid();
  setStatus('merge', `${mergeState.files.length} arquivo(s) prontos para unir. Arraste para reordenar.`);
  showToast('Arquivos carregados!', 'success');
  $('#mergeProgressBar').style.width = '0%';
});

async function renderMergePreviewGrid() {
  const grid = $('#mergePreviewGrid');
  grid.innerHTML = '';
  for (let i = 0; i < mergeState.files.length; i++) {
    const file = mergeState.files[i];
    const previewPdf = mergeState.previews[i];
    // Renderizar primeira página do PDF
    const page = await previewPdf.getPage(1);
    const vp = page.getViewport({scale: 0.25});
    const canvas = document.createElement('canvas');
    canvas.width = Math.floor(vp.width);
    canvas.height = Math.floor(vp.height);
    await page.render({canvasContext: canvas.getContext('2d'), viewport: vp}).promise;
    const div = document.createElement('div');
    div.className = 'thumb p-2 flex flex-col items-center';
    div.innerHTML = `
      <div class="mb-2 text-sm">${file.name}</div>
      <div class="mb-2 text-xs text-gray-500">Página 1</div>
    `;
    div.appendChild(canvas);
    grid.appendChild(div);
  }
  // Permitir arrastar para reordenar
  Sortable.create(grid, {
    animation: 150,
    onEnd: function (evt) {
      const oldFiles = mergeState.files.slice();
      const movedFile = oldFiles.splice(evt.oldIndex, 1)[0];
      oldFiles.splice(evt.newIndex, 0, movedFile);
      mergeState.files = oldFiles;
      // Reordenar pdfs e previews também
      const oldPdfs = mergeState.pdfs.slice();
      const movedPdf = oldPdfs.splice(evt.oldIndex, 1)[0];
      oldPdfs.splice(evt.newIndex, 0, movedPdf);
      mergeState.pdfs = oldPdfs;
      const oldPreviews = mergeState.previews.slice();
      const movedPreview = oldPreviews.splice(evt.oldIndex, 1)[0];
      oldPreviews.splice(evt.newIndex, 0, movedPreview);
      mergeState.previews = oldPreviews;
      renderMergePreviewGrid();
    }
  });
}

$('#btnMerge').addEventListener('click', async () => {
  if (!mergeState.files.length) {
    setStatus('merge', 'Selecione arquivos PDF.');
    showToast('Selecione arquivos PDF.', 'error');
    return;
  }
  $('#btnMerge').disabled = true;
  $('#mergeProgressBar').style.width = '0%';
  withSpinner('merge', 'Unindo PDFs...');
  try {
    const mergedPdf = await PDFDocument.create();
    setStatus('merge', 'Processando arquivos...');
    for (let i = 0; i < mergeState.pdfs.length; i++) {
      setStatus('merge', `Adicionando "${mergeState.files[i].name}" (${i+1}/${mergeState.pdfs.length})...`);
      $('#mergeProgressBar').style.width = `${Math.round((i/mergeState.pdfs.length)*100)}%`;
      const pdf = mergeState.pdfs[i];
      const pages = await mergedPdf.copyPages(pdf, pdf.getPageIndices());
      pages.forEach(p => mergedPdf.addPage(p));
    }
    $('#mergeProgressBar').style.width = '100%';
    setStatus('merge', 'Salvando PDF final...');
    const outBytes = await mergedPdf.save();
    downloadBlob(new Blob([outBytes], {type: 'application/pdf'}), 'unido.pdf');
    setStatus('merge', 'PDFs unidos com sucesso!');
    showToast('PDFs unidos!', 'success');
  } catch (err) {
    setStatus('merge', 'Erro ao unir PDFs: ' + (err.message || err));
    showToast('Erro ao unir PDFs: ' + (err.message || err), 'error');
  } finally {
    $('#btnMerge').disabled = false;
  }
});

// Girar/Reordenar Páginas
//------------------------------------------------------------
// ...adicione antes do comentário das outras ferramentas...

$('#tab-rotate').innerHTML = `
  <h2 class="text-xl font-semibold mb-4">Girar / Reordenar páginas</h2>
  <input type="file" id="rotateFile" accept="application/pdf" class="mb-4" />
  <div id="rotateGrid" class="grid grid-cols-2 md:grid-cols-3 gap-4 mb-4"></div>
  <div class="flex gap-3 mb-4">
    <button id="btnRotate90" class="btn-secondary">Girar 90°</button>
    <button id="btnRotate180" class="btn-secondary">Girar 180°</button>
    <button id="btnRotate270" class="btn-secondary">Girar 270°</button>
    <button id="btnResetRotation" class="btn-secondary">Resetar rotação</button>
  </div>
  <button id="btnExportRotate" class="btn-primary">Exportar PDF</button>
  <div id="rrStatus" class="text-sm text-gray-500 mt-2"></div>
  <div class="mb-4">
    <h3 class="text-sm font-medium text-gray-700 mb-2">Pré-visualização das páginas</h3>
    <div id="rotatePreviewGrid" class="grid grid-cols-2 md:grid-cols-3 gap-4"></div>
  </div>
`;

let rrState = { doc: null, order: [], rotations: [] };
let rotatePreviewPdf = null;

$('#rotateFile').addEventListener('change', async (e) => {
  const f = e.target.files[0];
  if (!f) return;
  if (f.size > MAX_SIZE) {
    setStatus('rr', 'Arquivo muito grande (máx. 20MB): ' + f.name);
    showToast('Arquivo muito grande: ' + f.name, 'error');
    e.target.value = '';
    return;
  }
  try {
    withSpinner('rr','Carregando PDF...');
    const bytes = await readAsArrayBuffer(f);
    rrState.doc = await PDFDocument.load(bytes);
    rrState.order = rrState.doc.getPageIndices();
    rrState.rotations = Array(rrState.order.length).fill(0);
    rotatePreviewPdf = await pdfjsLib.getDocument({data: bytes}).promise;
    await renderRotateGrid();
    await renderRotatePreview();
    setStatus('rr', `PDF carregado — ${rrState.order.length} página(s).`);
    showToast(`PDF carregado com ${rrState.order.length} páginas`, 'success');
  } catch (err) {
    setStatus('rr','Erro ao abrir PDF: ' + (err.message || err));
    showToast('Erro ao carregar o PDF: ' + (err.message || err), 'error');
  }
});

async function renderRotateGrid() {
  const grid = $('#rotateGrid');
  grid.innerHTML = '';
  for (let i = 0; i < rrState.order.length; i++) {
    const pageNum = rrState.order[i];
    const div = document.createElement('div');
    div.className = 'thumb p-2 flex flex-col items-center';
    div.innerHTML = `
      <div class="mb-2 text-sm">Página ${pageNum + 1}</div>
      <div class="mb-2">Rotação: <span id="rot${i}">${rrState.rotations[i]}°</span></div>
      <button class="btn-secondary mb-2" data-idx="${i}">Selecionar</button>
    `;
    grid.appendChild(div);
  }
  Sortable.create(grid, {
    animation: 150,
    onEnd: function (evt) {
      const oldOrder = rrState.order.slice();
      const moved = oldOrder.splice(evt.oldIndex, 1)[0];
      oldOrder.splice(evt.newIndex, 0, moved);
      rrState.order = oldOrder;
      const oldRot = rrState.rotations.slice();
      const movedRot = oldRot.splice(evt.oldIndex, 1)[0];
      oldRot.splice(evt.newIndex, 0, movedRot);
      rrState.rotations = oldRot;
      renderRotateGrid();
      renderRotatePreview(); // Atualiza preview ao reordenar
    }
  });
}

function getSelectedIdx() {
  const btns = $$('#rotateGrid button');
  for (let i = 0; i < btns.length; i++) {
    if (btns[i].classList.contains('selected')) return i;
  }
  return null;
}

$$('#rotateGrid').forEach(grid => {
  grid.addEventListener('click', e => {
    if (e.target.tagName === 'BUTTON') {
      $$('#rotateGrid button').forEach(b => b.classList.remove('selected'));
      e.target.classList.add('selected');
    }
  });
});

function rotateSelected(deg) {
  const idx = getSelectedIdx();
  if (idx === null) {
    setStatus('rr','Selecione uma página.');
    showToast('Selecione uma página para girar.', 'error');
    return;
  }
  rrState.rotations[idx] = (rrState.rotations[idx] + deg) % 360;
  $(`#rot${idx}`).textContent = `${rrState.rotations[idx]}°`;
  renderRotatePreview(); // Atualiza preview ao girar
}

$('#btnRotate90').addEventListener('click', () => rotateSelected(90));
$('#btnRotate180').addEventListener('click', () => rotateSelected(180));
$('#btnRotate270').addEventListener('click', () => rotateSelected(270));
$('#btnResetRotation').addEventListener('click', () => {
  const idx = getSelectedIdx();
  if (idx === null) return;
  rrState.rotations[idx] = 0;
  $(`#rot${idx}`).textContent = '0°';
  renderRotatePreview(); // Atualiza preview ao resetar
});

$('#btnExportRotate').addEventListener('click', async () => {
  if (!rrState.doc) {
    setStatus('rr','Carregue um PDF primeiro.');
    showToast('Carregue um PDF primeiro.', 'error');
    return;
  }
  $('#btnExportRotate').disabled = true;
  withSpinner('rr','Exportando...');
  try {
    const out = await PDFDocument.create();
    for (let i = 0; i < rrState.order.length; i++) {
      const [page] = await out.copyPages(rrState.doc, [rrState.order[i]]);
      page.setRotation(degrees(rrState.rotations[i]));
      out.addPage(page);
    }
    const bytes = await out.save();
    downloadBlob(new Blob([bytes], {type: 'application/pdf'}), 'girado.pdf');
    setStatus('rr','PDF exportado!');
    showToast('PDF exportado!', 'success');
  } catch (err) {
    setStatus('rr','Erro ao exportar PDF: ' + (err.message || err));
    showToast('Erro ao exportar PDF: ' + (err.message || err), 'error');
  } finally {
    $('#btnExportRotate').disabled = false;
  }
});

// Pré-visualização das páginas rotacionadas
async function renderRotatePreview() {
  const grid = $('#rotatePreviewGrid');
  grid.innerHTML = '';
  if (!rotatePreviewPdf || !rrState.order.length) return;
  for (let i = 0; i < rrState.order.length; i++) {
    const pageNum = rrState.order[i] + 1;
    const rotation = rrState.rotations[i];
    const page = await rotatePreviewPdf.getPage(pageNum);
    const vp = page.getViewport({scale: 0.25, rotation: rotation});
    const canvas = document.createElement('canvas');
    canvas.width = Math.floor(vp.width);
    canvas.height = Math.floor(vp.height);
    const ctx = canvas.getContext('2d');
    ctx.save();
    // O pdf.js já aplica a rotação via viewport, não precisa girar manualmente
    ctx.restore();
    await page.render({canvasContext: ctx, viewport: vp}).promise;
    const div = document.createElement('div');
    div.className = 'thumb p-2 flex flex-col items-center';
    div.innerHTML = `<div class="mb-2 text-sm">Página ${pageNum} (${rotation}°)</div>`;
    div.appendChild(canvas);
    grid.appendChild(div);
  }
}




// Anotar PDF (Adicionar texto simples)
//-----------------------------------------

$('#tab-annotate').innerHTML = `
  <h2 class="text-xl font-semibold mb-4">Anotar PDF</h2>
  <input type="file" id="annotateFile" accept="application/pdf" class="mb-4" />
  <input type="text" id="annotateText" placeholder="Texto para adicionar" class="mb-4" />
  <input type="number" id="annotatePage" min="1" value="1" class="mb-4" />
  <div class="flex gap-3 mb-4 flex-wrap">
    <label class="flex items-center gap-2">
      <span>Cor:</span>
      <input type="color" id="annotateColor" value="#1e40af" />
    </label>
    <label class="flex items-center gap-2">
      <span>X:</span>
      <input type="number" id="annotateX" value="50" min="0" style="width:70px;" />
    </label>
    <label class="flex items-center gap-2">
      <span>Y:</span>
      <input type="number" id="annotateY" value="50" min="0" style="width:70px;" />
    </label>
    <label class="flex items-center gap-2">
      <span>Tamanho:</span>
      <input type="number" id="annotateFontSize" value="18" min="8" max="100" style="width:70px;" />
    </label>
    <label class="flex items-center gap-2">
      <span>Fonte:</span>
      <select id="annotateFontFamily" style="width:120px;">
        <option value="Helvetica">Helvetica</option>
        <option value="TimesRoman">Times</option>
        <option value="Courier">Courier</option>
      </select>
    </label>
    <button id="moveLeft" class="btn-secondary" title="Mover para esquerda">←</button>
    <button id="moveUp" class="btn-secondary" title="Mover para cima">↑</button>
    <button id="moveDown" class="btn-secondary" title="Mover para baixo">↓</button>
    <button id="moveRight" class="btn-secondary" title="Mover para direita">→</button>
  </div>
  <button id="btnAnnotate" class="btn-primary">Adicionar texto e baixar</button>
  <div id="annStatus" class="text-sm text-gray-500 mt-2"></div>
  <div class="mb-4">
    <h3 class="text-sm font-medium text-gray-700 mb-2">Pré-visualização</h3>
    <canvas id="annotatePreview" style="border:1px solid #e5e7eb; border-radius:8px; background:#fff; max-width:100%;"></canvas>
  </div>
`;

let annState = { doc: null, numPages: 0 };
let previewPdf = null;

$('#annotateFile').addEventListener('change', async (e) => {
  const f = e.target.files[0];
  if (!f) return;
  if (f.size > MAX_SIZE) {
    setStatus('ann', 'Arquivo muito grande (máx. 20MB): ' + f.name);
    showToast('Arquivo muito grande: ' + f.name, 'error');
    e.target.value = '';
    return;
  }
  try {
    withSpinner('ann','Carregando PDF...');
    const bytes = await readAsArrayBuffer(f);
    annState.doc = await PDFDocument.load(bytes);
    annState.numPages = annState.doc.getPageCount();
    setStatus('ann', `PDF carregado — ${annState.numPages} página(s).`);
    showToast(`PDF carregado com ${annState.numPages} páginas`, 'success');
    $('#annotatePage').max = annState.numPages;

    // Carregar para preview
    previewPdf = await pdfjsLib.getDocument({data: bytes}).promise;
    renderAnnotatePreview();
  } catch (err) {
    setStatus('ann','Erro ao abrir PDF: ' + (err.message || err));
    showToast('Erro ao carregar o PDF: ' + (err.message || err), 'error');
  }
});
// =============================================================================================
$('#btnAnnotate').addEventListener('click', async () => {
  if (!annState.doc) {
    setStatus('ann','Carregue um PDF primeiro.');
    showToast('Carregue um PDF primeiro.', 'error');
    return;
  }
  $('#btnAnnotate').disabled = true;
  const text = $('#annotateText').value;
  const pageNum = parseInt($('#annotatePage').value, 10) - 1;
  const colorHex = $('#annotateColor').value;
  const x = parseInt($('#annotateX').value, 10);
  const y = parseInt($('#annotateY').value, 10);
  const fontSize = parseInt($('#annotateFontSize').value, 10) || 18;
  const fontFamily = $('#annotateFontFamily').value;

  if (!text || isNaN(pageNum) || pageNum < 0 || pageNum >= annState.numPages) {
    setStatus('ann','Preencha o texto e página corretamente.');
    showToast('Preencha o texto e página corretamente.', 'error');
    $('#btnAnnotate').disabled = false;
    return;
  }
  if (isNaN(x) || isNaN(y)) {
    setStatus('ann','Preencha X e Y corretamente.');
    showToast('Preencha X e Y corretamente.', 'error');
    $('#btnAnnotate').disabled = false;
    return;
  }
  withSpinner('ann','Adicionando anotação...');
  try {
    let font;
    if (fontFamily === 'Helvetica') font = await annState.doc.embedFont(StandardFonts.Helvetica);
    else if (fontFamily === 'TimesRoman') font = await annState.doc.embedFont(StandardFonts.TimesRoman);
    else if (fontFamily === 'Courier') font = await annState.doc.embedFont(StandardFonts.Courier);
    else font = await annState.doc.embedFont(StandardFonts.Helvetica);

    const page = annState.doc.getPage(pageNum);

    // Converter cor hex para rgb
    function hexToRgb(hex) {
      const v = hex.replace('#','');
      return {
        r: parseInt(v.substring(0,2),16)/255,
        g: parseInt(v.substring(2,4),16)/255,
        b: parseInt(v.substring(4,6),16)/255
      };
    }
    const rgbColor = hexToRgb(colorHex);

    page.drawText(text, {
      x: x,
      y: y,
      size: fontSize,
      font,
      color: rgb(rgbColor.r, rgbColor.g, rgbColor.b)
    });
    const bytes = await annState.doc.save();
    downloadBlob(new Blob([bytes], {type: 'application/pdf'}), 'anotado.pdf');
    setStatus('ann','Texto adicionado!');
    showToast('Texto adicionado!', 'success');
  } catch (err) {
    setStatus('ann','Erro ao anotar PDF: ' + (err.message || err));
    showToast('Erro ao anotar PDF: ' + (err.message || err), 'error');
  } finally {
    $('#btnAnnotate').disabled = false;
  }
});
// ==============================================================================================
function renderAnnotatePreview() {
  if (!previewPdf) return;
  const pageNum = parseInt($('#annotatePage').value, 10) || 1;
  previewPdf.getPage(pageNum).then(page => {
    const vp = page.getViewport({scale: 1});
    const previewCanvas = $('#annotatePreview');
    previewCanvas.width = vp.width;
    previewCanvas.height = vp.height;
    const ctx = previewCanvas.getContext('2d');
    ctx.clearRect(0, 0, vp.width, vp.height);
    page.render({canvasContext: ctx, viewport: vp}).promise.then(() => {
      // Desenhar texto sobre o canvas
      const text = $('#annotateText').value;
      const x = parseInt($('#annotateX').value, 10) || 0;
      const y = parseInt($('#annotateY').value, 10) || 0;
      const color = $('#annotateColor').value || '#1e40af';
      const fontSize = parseInt($('#annotateFontSize').value, 10) || 18;
      const fontFamily = $('#annotateFontFamily').value;
      let fontCss = 'bold';
      if (fontFamily === 'Helvetica') fontCss += ` ${fontSize}px Arial, Helvetica, sans-serif`;
      else if (fontFamily === 'TimesRoman') fontCss += ` ${fontSize}px Times, Times New Roman, serif`;
      else if (fontFamily === 'Courier') fontCss += ` ${fontSize}px Courier, monospace`;
      else fontCss += ` ${fontSize}px Arial, Helvetica, sans-serif`;
      ctx.font = fontCss;
      ctx.fillStyle = color;
      ctx.fillText(text, x, vp.height - y);
    });
  });
}

// Atualize preview ao mudar campos
['annotateText','annotatePage','annotateColor','annotateX','annotateY','annotateFontSize','annotateFontFamily'].forEach(id => {
  $(`#${id}`).addEventListener('input', renderAnnotatePreview);
});

// Botões de mover texto
const step = 10; // pixels por clique

$('#moveLeft').addEventListener('click', () => {
  const x = $('#annotateX');
  x.value = Math.max(0, parseInt(x.value, 10) - step);
  renderAnnotatePreview();
});
$('#moveRight').addEventListener('click', () => {
  const x = $('#annotateX');
  x.value = parseInt(x.value, 10) + step;
  renderAnnotatePreview();
});
$('#moveUp').addEventListener('click', () => {
  const y = $('#annotateY');
  y.value = parseInt(y.value, 10) + step;
  renderAnnotatePreview();
});
$('#moveDown').addEventListener('click', () => {
  const y = $('#annotateY');
  y.value = Math.max(0, parseInt(y.value, 10) - step);
  renderAnnotatePreview();
});





// Compactar PDF
// ------------------------------------------------------
// ...substitua o bloco COMPRESS pelo abaixo...

$('#tab-compress').innerHTML = `
  <h2 class="text-xl font-semibold mb-4">Compactar PDF</h2>
  <input type="file" id="compressFile" accept="application/pdf" class="mb-4" />
  <button id="btnCompress" class="btn-primary">Compactar e baixar</button>
  <div id="cmpStatus" class="text-sm text-gray-500 mt-2"></div>
`;

let cmpState = { doc: null };

$('#compressFile').addEventListener('change', async (e) => {
  const f = e.target.files[0];
  if (!f) return;
  if (f.size > MAX_SIZE) {
    setStatus('cmp', 'Arquivo muito grande (máx. 20MB): ' + f.name);
    showToast('Arquivo muito grande: ' + f.name, 'error');
    e.target.value = '';
    return;
  }
  try {
    withSpinner('cmp','Carregando PDF...');
    const bytes = await readAsArrayBuffer(f);
    cmpState.doc = await PDFDocument.load(bytes);
    setStatus('cmp', `PDF carregado — ${cmpState.doc.getPageCount()} página(s).`);
    showToast(`PDF carregado com ${cmpState.doc.getPageCount()} páginas`, 'success');
  } catch (err) {
    setStatus('cmp','Erro ao abrir PDF: ' + (err.message || err));
    showToast('Erro ao carregar o PDF: ' + (err.message || err), 'error');
  }
});

$('#btnCompress').addEventListener('click', async () => {
  if (!cmpState.doc) {
    setStatus('cmp','Carregue um PDF primeiro.');
    showToast('Carregue um PDF primeiro.', 'error');
    return;
  }
  $('#btnCompress').disabled = true;
  withSpinner('cmp','Compactando...');
  try {
    cmpState.doc.setTitle('');
    cmpState.doc.setAuthor('');
    cmpState.doc.setSubject('');
    cmpState.doc.setKeywords([]);
    cmpState.doc.setProducer('');
    cmpState.doc.setCreator('');
    const bytes = await cmpState.doc.save({ useObjectStreams: true, addDefaultPage: false });
    downloadBlob(new Blob([bytes], {type: 'application/pdf'}), 'compactado.pdf');
    setStatus('cmp','PDF compactado!');
    showToast('PDF compactado!', 'success');
  } catch (err) {
    setStatus('cmp','Erro ao compactar PDF: ' + (err.message || err));
    showToast('Erro ao compactar PDF: ' + (err.message || err), 'error');
  } finally {
    $('#btnCompress').disabled = false;
  }
});
  </script>
</body>
</html>
